---
title: Java知识点：byte数据溢出
date: 2019-12-08 15:59:31
tags:
    - byte
categories: Java
---

```java
byte a = 127;
b = a + 1;
c = a + 2;
System.out.println(a);
System.out.println(b);
System.out.println(c);
```
运行结果：
>127
>
>-128
>
>-127
<!--more-->
结果分析：我们知道`byte`的数据大小范围为`-128-127`。所以127+1之后，就会超出byte的存储范围。那么我们就需要了解计算机如何存储数据，以及加减操作。我们知道`byte`表示字节类型，1字节=8位，所以byte在计算机中是8位二进制存储的。

计算机在存储数据的时候，是以二进制的形式进行存储。那么`127`的二进制`01111111`。计算机在存储有符号数时，将最高位设置为`符号位`。也就是`byte`最大值等于`127`的原因。

在这里还要补充下原码、反码、补码的知识：[原码、反码、补码的产生、应用以及优缺点有哪些？](https://www.zhihu.com/question/20159860)
- 为了解决“正负相加等于0”的问题，在“原码”的基础上，人们发明了“反码”
- 因为两个零存在，+0 和 -0，我们希望只有一个0，所以发明了"补码"

|-|原码|反码|补码|
|-|-|-|-|
|正数|本身|本身|本身|
|负数|本身|除符号位不变，其他按位取反|反码+1

有了以上知识，那么我们看看计算机如何进行加减法的操作，以及数据溢出是怎么回事。首先我们以`1+1`为例：
```shell
  00000001
+ 00000001
----------
  00000010
```
所以`1+1=2`没问题。

`127+1`
```shell
  01111111
+ 00000001
----------
  10000000
```
这是127+1的操作，我们知道最高位1表示负数，所以127+1结果为负数。`10000000`是某个数的补码，那么这个数是多少？由上面原码、反码、补码知识我们知道`补码-1`得到`反码`，然后再得到`原码`。但是实际上`10000000`比较特殊，因为规定`10000000`是`-128`的补码。所以，就知道了`127-1=-128`。

**同理：**`127+2`
```shell
  011111111
+ 000000010
-----------
  100000001
```
**计算原码：**`~(10000001-1)= ~10000000 = 11111111  = -127`

总结：我们知道了加法的操作之后，就知道计算机是如何进行减法的，减去一个数等于加上这个数的负数。由此，我们不仅知道计算机是如何做加减法的，还知道了当数据加减溢出后会出现什么情况。

**思考：**
```java
byte a = 425;
System.out.println(a);
```
由于byte只能存储8位，所以425转换为二进制的时候，会只保留后8位`10101001.`，最高位是1，所以是个负数。求得原码为: `11010111`即`-87`。

